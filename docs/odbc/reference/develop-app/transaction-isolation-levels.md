---
description: " (ODBC) 的事务隔离级别"
title: " (ODBC) 的事务隔离级别 |Microsoft Docs"
ms.custom: seo-dt-2019
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: aa4f5b0269760b648e0a499ea550901e7db6e74f
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/17/2020
ms.locfileid: "88487470"
---
# <a name="transaction-isolation-levels-odbc"></a> (ODBC) 的事务隔离级别
*事务隔离级别* 是事务隔离成功的程度的度量值。 特别是，事务隔离级别是通过存在还是不存在以下现象定义的：  
  
-   **脏读** 如果事务读取尚未提交的数据，则会发生 *脏读* 。 例如，假设事务1更新一行。 事务2在事务1提交更新之前读取更新的行。 如果事务1回滚更改，则事务2将具有被视为永不存在的读取数据。  
  
-   **不可重复读取** 如果事务读取同一行两次，但每次都获取不同的数据，则会发生 *不可重复读取* 。 例如，假设事务1读取了一行。 事务2更新或删除该行，并提交更新或删除。 如果事务1重新该行，则检索不同的行值或发现该行已被删除。  
  
-   **幻像***虚拟*的行与搜索条件匹配，但最初并未显示。 例如，假设事务1读取一组满足某些搜索条件的行。 事务2通过与事务1的搜索条件匹配的 update 或 insert) 生成新的行 (。 如果事务 1 reexecutes 读取行的语句，则将获取一组不同的行。  
  
 由 SQL-92) 定义 (的四个事务隔离级别是根据这些现象定义的。 在下表中，"X" 标记每个可能出现的现象。  
  
|事务隔离级别|脏读|不可重复读取|幻像|  
|---------------------------------|-----------------|-------------------------|--------------|  
|未提交读|X|X|X|  
|已提交读|--|X|X|  
|可重复读|--|--|X|  
|可序列化|--|--|--|  
  
 下表描述了 DBMS 可能实现事务隔离级别的简单方式。  
  
> [!IMPORTANT]  
>  大多数 Dbms 使用比这些方案更复杂的方案来提高并发性。 这些示例仅供说明之用。 特别是，ODBC 不规定特定 Dbms 如何相互隔离事务。  
  
|事务隔离|可能的实现|  
|---------------------------|-----------------------------|  
|未提交读|事务不彼此隔离。 如果 DBMS 支持其他事务隔离级别，则它会忽略用于实现这些级别的任何机制。 因此，它们不会对其他事务产生不利影响，在读取未提交级别运行的事务通常是只读的。|  
|已提交读|事务将一直等待，直到锁定由其他事务锁定的行;这可防止其读取任何 "脏" 数据。<br /><br />  () 如果事务在当前行上更新或删除行) ，以防止其他事务更新或删除行，则事务将持有读取锁定 (。 事务在离开当前行时释放读取锁定。 它保留写入锁定，直到提交或回滚。|  
|可重复读|事务将一直等待，直到锁定由其他事务锁定的行;这可防止其读取任何 "脏" 数据。<br /><br /> 事务保留对其返回到应用程序的所有行的读取锁定，并在其插入、更新或删除的所有行上写入锁。 例如，如果事务包含 SQL 语句 " ** \* 从订单**" 中选择，则事务会在获取应用程序时读取锁行。 如果事务包含 **Status = "CLOSED" 的 ORDERS 中**的 SQL 语句 DELETE，则事务会将其删除。<br /><br /> 由于其他事务不能更新或删除这些行，因此当前事务可避免任何不可重复读取。 事务在提交或回滚时将释放其锁。|  
|可序列化|事务将一直等待，直到锁定由其他事务锁定的行;这可防止其读取任何 "脏" 数据。<br /><br /> 如果事务只读取行) 或写入锁定 (，则该事务将保留读取锁定，如果它可以更新或删除它所影响的行) 的行，则 (。 例如，如果事务包含 SQL 语句 " ** \* 从订单**" 中选择，则范围为整个 orders 表; 该事务读取表，不允许将任何新行插入到该表中。 如果事务包含 **status = "closed"** 状态下的 SQL 语句 "删除顺序"，则该范围为状态为 "已关闭" 的所有行;事务写入会锁定 Orders 表中状态为 "已关闭" 的所有行，不允许插入或更新任何行，从而使结果行的状态为 "已关闭"。<br /><br /> 由于其他事务不能更新或删除该范围内的行，因此当前事务可避免任何不可重复读取。 由于其他事务不能在该范围中插入任何行，因此当前事务可避免任何幻像。 该事务在提交或回滚时将释放其锁。|  
  
 请务必注意，事务隔离级别不会影响事务查看其自身的更改的能力;事务可以始终看到它们所做的任何更改。 例如，某一事务可能由两个 **UPDATE** 语句组成，其中第一个语句将每个雇员的工资支付为10%，另一个则将每位员工的付款量设置为超过该量的最大数量。 这仅作为单个事务成功，因为第二个 **UPDATE** 语句可以查看第一个的结果。
